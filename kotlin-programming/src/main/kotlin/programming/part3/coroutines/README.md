# Chapter 15

- 코루틴... 멀티 쓰레드..?

## 코루틴 vs 서브루틴

- 범용프로그래밍에서 코루틴 < 서브루틴.. 서브루틴이란 실행이 완료된 이후에 호출자에게 반환되는 함수다.
- 서브루틴
    - 엔트리가 한개
- 코루틴
    - 엔트리가 여러개
        - 호출 사이에 상태를 기억할 수 있다.
        - 코루틴을 호출하면 이전 호출에서 중단된 코루틴의 중간으로 들어갈 수 있다.

## 코루틴 작동 방식

- Producer 코루틴이 Consumer 코루틴을 호출
- Consumer 코드의 부분실행이 끝나면 Consumer는 현재 상태를 저장
- 호출자에게 리턴 또는 일드(yield)를 한다.
- Producer는 몇 단계를 더 수행하고 다시 Consumer에게 콜백
- 이번엔 처음부터 시작하는게 아니고 이전 실행이 멈춘 부분부터 이전 호출 상태를 복구하고 다시 시작

## 코루틴을 이용한 동시 실행

- sequential, coroutine, interleave

## 코루틴의 컨텍스트와 스레드

- launch()와 runBlocing()를 호출하면 호출자의 코루틴 스코프와 같은 스레드에서 코루틴을 실행한다.
    - 이유: 함수들이 함수의 스코프에서 코루틴 컨텍스트를 옮기기 때문!
    - 하지만 코루틴의 실행의 컨텍스트와 스레드를 원하는 곳으로 변경 가능!

### 컨텍스트 명시적 세팅

- CoroutineContext 타입의 아규먼트인 Dispatchers.Default의 값이 코루틴에게 DefaultDispatcher 풀의 스레드 안에서 실행을 시작하라고 지시한다. 풀 안의 스레드 숫자는
  2개이거나 시스템의 코어 숫자 중 높은 것을 사용한다.
- 이 풀은 계산할 일이 많은 작업들을 위한 풀이다.

- Dispathchers.IO의 값은 IO 작업을 실행을 위한 풀 안의 코루틴을 실행시키는데 사용될 수 있다. 이 풀은 스레드가 IO에 블록될 경우와 작업이 더 생성된 경우 사이즈가 커질수 있다.
- Dispatchers.Main은 안드로이드 기기와 Swing UI에서 사용된다. 사용되는 예로는 main 스레드에서만 사용되는 UI 업데이트 기능을 실행하는 것!
- single

### 서스펜션 포인트 이후에 스레드 스위칭!

- 작업이 빠른 연산을 포함하는 스레드는 현재 스레드에서 실행시키고 싶다.
- 작업이 느린 연산을 하는 인스턴스라면 다른 스레드로 실행을 델리게이트 하고 싶다!
- CoroutineStart 아규먼트와 CoroutineContext 아규먼트를 사용하자!
- coroutinestart, withcontext

## async, await

- launch() 함수는 Job객체를 리턴한다!
- Job객체는 코루틴의 종료를 기다리거나 취소를 기다리기 위해 사용! 하지만 launch()를 이용해서 시작된 코루틴에서는 결과를 리턴 받을 방법이 없다.
- 작업을 비동기로 실행하고 실행결과를 원한다면 launch() 대신 async()를 사용하자
- async() 는 Deferred<T> 퓨처 객체를 리턴
- Deferred 객체는 상태 체크 및 await() 메소드를 가지고 있다.
- asyncawait

## 연속성 살펴보기

- compute, UseCompute

## 무한 시퀀스

- primes, forstringrange

## 정리

- 코루틴은 컨티뉴에이션의 개념을 기반으로 태어남
- 코루틴은 동시성 프로그래밍을 만들기 위한 좋은 방법
- 코루틴은 다중 엔트리포인트를 가지고 있는 함수
- 코루틴은 호출들 사이에서 상태를 전달 가능. 이런 함수들은 서로 호출할 수 있고 이전 호출에서 중단된 부분부터 다시 실행 가능
- 코루틴이 실행되고 있는 스레드를 변경할 수 있고, async()/await()를 사용하면 병렬로 실행한 후 나중에 결과를 받을 수 있음

